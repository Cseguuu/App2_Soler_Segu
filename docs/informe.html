<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Informe Técnico del Proyecto de Análisis de Pedidos de Pizza</title>
    <link
      href="https://fonts.googleapis.com/css?family=Open+Sans:400,600,700&display=swap"
      rel="stylesheet"
    />
    <style>
      /* Reset y configuración base */
      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }
      body {
        font-family: "Open Sans", sans-serif;
        line-height: 1.6;
        background-color: #f8f9fa;
        color: #343a40;
        padding: 0;
        margin: 0;
      }
      .container {
        max-width: 960px;
        margin: 0 auto;
        padding: 0 20px;
      }
      header {
        background-color: #00529b;
        color: #ffffff;
        padding: 30px 0;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      }
      .header-content {
        max-width: 960px;
        margin: 0 auto;
        padding: 0 20px;
        text-align: center;
      }
      header h1 {
        margin-bottom: 10px;
        font-size: 2.2rem;
      }
      header p {
        font-size: 1.2rem;
        opacity: 0.9;
      }
      nav {
        background-color: #fff;
        margin: 0;
        padding: 15px 0;
        position: sticky;
        top: 0;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        z-index: 100;
      }
      nav .container {
        overflow-x: auto;
      }
      nav ul {
        list-style: none;
        display: flex;
        flex-wrap: nowrap;
        justify-content: center;
        min-width: min-content;
      }
      nav ul li {
        margin: 5px 15px;
        white-space: nowrap;
      }
      nav ul li a {
        color: #00529b;
        text-decoration: none;
        font-weight: 600;
        transition: all 0.2s ease;
        padding: 5px 0;
        position: relative;
      }
      nav ul li a::after {
        content: "";
        position: absolute;
        bottom: 0;
        left: 0;
        width: 0;
        height: 2px;
        background-color: #00529b;
        transition: width 0.3s ease;
      }
      nav ul li a:hover::after {
        width: 100%;
      }
      main {
        padding: 40px 0;
      }
      h2 {
        color: #00529b;
        margin-top: 20px;
        margin-bottom: 20px;
        border-bottom: 2px solid #00529b;
        padding-bottom: 10px;
        font-size: 1.8rem;
      }
      p {
        margin: 16px 0;
        font-size: 1rem;
      }
      ul {
        margin: 16px 0 16px 20px;
      }
      ul li {
        margin-bottom: 8px;
      }
      pre {
        background-color: #e9ecef;
        padding: 15px;
        overflow-x: auto;
        border-radius: 8px;
        margin: 16px 0;
        border-left: 4px solid #00529b;
      }
      code {
        font-family: Consolas, Monaco, "Andale Mono", monospace;
        font-size: 0.95em;
      }
      .diagrama {
        text-align: center;
        margin: 30px 0;
        padding: 20px;
        background-color: #fff;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      }
      .content-section {
        margin-bottom: 60px;
        background-color: #fff;
        padding: 30px;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
      }
      footer {
        background-color: #343a40;
        color: #ffffff;
        padding: 20px 0;
        text-align: center;
        font-size: 0.9rem;
      }
      /* Estilo para los enlaces de anclaje - scrolling suave */
      html {
        scroll-behavior: smooth;
        scroll-padding-top: 70px; /* Ajuste para la barra de navegación fija */
      }
      /* Estilos para resaltar los elementos strong */
      strong {
        color: #00529b;
        font-weight: 600;
      }
      /* Estilos para pantallas pequeñas */
      @media (max-width: 768px) {
        header h1 {
          font-size: 1.8rem;
        }
        header p {
          font-size: 1rem;
        }
        .content-section {
          padding: 20px;
        }
        nav {
          padding: 10px 0;
        }
      }
      /* Añadir un efecto de hover a las secciones */
      .content-section:hover {
        transform: translateY(-2px);
        transition: transform 0.3s ease;
      }
      /* Animación para cargar las secciones */
      @keyframes fadeIn {
        from {
          opacity: 0;
          transform: translateY(20px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }
      .content-section {
        animation: fadeIn 0.5s ease-out forwards;
      }
      .content-section:nth-child(1) {
        animation-delay: 0.1s;
      }
      .content-section:nth-child(2) {
        animation-delay: 0.2s;
      }
      .content-section:nth-child(3) {
        animation-delay: 0.3s;
      }
      .content-section:nth-child(4) {
        animation-delay: 0.4s;
      }
      .content-section:nth-child(5) {
        animation-delay: 0.5s;
      }
      .content-section:nth-child(6) {
        animation-delay: 0.6s;
      }
      .content-section:nth-child(7) {
        animation-delay: 0.7s;
      }
      /* Estilo del botón para subir */
      #scrollToTopBtn {
        position: fixed;
        bottom: 20px;
        right: 20px;
        background-color: #00529b;
        color: #ffffff;
        border: none;
        border-radius: 50%;
        width: 50px;
        height: 50px;
        cursor: pointer;
        display: none;
        align-items: center;
        justify-content: center;
        font-size: 1.5rem;
        z-index: 200;
      }
      #scrollToTopBtn:hover {
        background-color: #003f7f;
      }
    </style>
  </head>
  <body>
    <header>
      <div class="header-content">
        <h1>Informe Técnico del Proyecto de Análisis de Pedidos de Pizza</h1>
        <p>Optimización, escalabilidad y buenas prácticas en C</p>
      </div>
    </header>

    <nav>
      <div class="container">
        <ul>
          <li><a href="#organizacion">Organización del Código</a></li>
          <li><a href="#estructuras">Estructuras de Datos</a></li>
          <li><a href="#modularidad">Modularidad</a></li>
          <li><a href="#punteros">Punteros a Funciones</a></li>
          <li><a href="#diagrama">Diagrama de Flujo</a></li>
          <li><a href="#interaccion">Interacción entre Archivos</a></li>
          <li><a href="#recursos">Recursos Externos</a></li>
          <li><a href="#reflexiones">Reflexiones</a></li>

        </ul>
      </div>
    </nav>

    <main>
      <div class="container">
        <section id="organizacion" class="content-section">
          <h2>1. Organización del Código</h2>
          <p>
            El proyecto se ha organizado siguiendo una estructura de carpetas
            convencional para proyectos en C, facilitando la localización y funcionamiento del código al separar claramente la interfaz y la implementación. La estructura es la siguiente:
          </p>
          <ul>
            <li>
              <strong>include/</strong> – Contiene los headers (<code>.h</code>)
              con las declaraciones de funciones y definiciones de estructuras
              de datos. 
            </li>
            <li>
              <strong>src/</strong> – Alberga el código fuente (<code>.c</code>)
              con la implementación, incluyendo módulos como
              <code>main.c</code>, <code>csv_parser.c</code> y
              <code>metrics.c</code>.
            </li>
            <li>
              <strong>test/</strong> – Incluye los datos de prueba, por ejemplo,
              el archivo CSV utilizado para verificar el funcionamiento del
              programa.
            </li>
          </ul>
          <p>
            Esta división en carpetas permite una mayor claridad en la gestión y
            escalabilidad del proyecto, facilitando el entendimiento y desarrollo del mismo.
          </p>
        </section>

        <section id="estructuras" class="content-section">
          <h2>2. Estructuras de Datos Empleadas</h2>
          <p>
            La estructura principal es <code>Order</code>, la cual representa un
            pedido individual de pizza. El codigo de la estructura está dado
            por:
          </p>
          <pre><code>typedef struct {
            double pizza_id;          // Identificador único de pizza
            double order_id;          // Identificador de orden
            char pizza_name_id[50];   // Identificador del nombre de pizza
            double quantity;          // Cantidad de pizzas
            char order_date[MAX_DATE_LENGTH];  // Fecha de la orden
            char order_time[20];      // Hora de la orden
            double unit_price;        // Precio unitario
            double total_price;       // Precio total
            char pizza_size[10];      // Tamaño de pizza
            char pizza_category[20];  // Categoría de pizza
            char pizza_ingredients[MAX_INGREDIENTS][50];  // Lista de ingredientes
            char pizza_name[MAX_PIZZA_NAME];  // Nombre completo de la pizza
            int num_ingredients;      // Número de ingredientes
        } Order;</code></pre>
          <p>
            Explicando más en profundidad lo que dicen en los comentarios de
            cada atributo, podemos ver que los campos representan:
          </p>
          <ul>
            <li>
              <code>pizza_id y order_id</code>: Identificadores únicos para la
              pizza y para el pedido, respectivamente.
            </li>
            <li>
              <code>pizza_name_id y pizza_name</code>: Uno puede verse como un
              identificador para el nombre y el otro como el nombre completo de
              la pizza.
            </li>
            <li><code>quantity</code>: Cantidad de pizzas en el pedido.</li>
            <li>
              <code>order_date y order_time</code>: Fecha y hora en que se
              realizó el pedido.
            </li>

            <li>
              <code>unit_price y total_price</code>: Precio unitario y precio
              total del pedido.
            </li>

            <li>
              <code>pizza_size y pizza_category</code>: Información sobre el
              tamaño y la categoría de la pizza.
            </li>
            <li>
              <code>pizza_ingredients y num_ingredients</code>: Una lista de
              ingredientes y el número de ingredientes presentes.
            </li>
          </ul>
          <p>
            Respecto a los tipos de datos utilizados para las distintas métricas se encuentran los siguientes:
          </p>
          <ul>
            <li>
              <code>Double</code>: para valores númericos: esto permite almacenar números enteros como decimales del CSV.
            </li>
            <li>
              <code>Arrays</code>: De caracteres de tamaño fijo para mantener el orden y flexibilidad.
            </li>
            <li><code>Interger</code>: Para cantidades de ingredientes.</li>
            </li>
          </ul>
          <p>
            Cada instancia de <code>Order</code> corresponde a una fila del
            archivo CSV, lo que facilita el acceso y manipulación de los datos
            de cada pedido de forma estructurada y eficiente.
          </p>
        </section>

        <section id="modularidad" class="content-section">
          <h2>3. Modularidad</h2>
          <p>
            El código se divide en múltiples módulos, permitiendo que cada uno
            cumpla una única responsabilidad, facilitando así el trabajo y entendimiento del código:
          </p>
          <ul>
            <li>
              <strong>csv_parser.c</strong>: Se encarga de leer y parsear el
              archivo CSV, convirtiendo cada línea en una estructura
              <code>Order</code>.
            </li>
            <li>
              <strong>metrics.c</strong>: Contiene funciones para el cálculo de
              diversas métricas a partir de los datos obtenidos.
            </li>
            <li>
              <strong>main.c</strong>: Coordina la ejecución del programa,
              integrando la lectura de datos, el cálculo de métricas y la
              interacción con el usuario.
            </li>
          </ul>
          <p>
            Esta separación en módulos ayuda a mantener el código limpio, reduce
            la dependencia entre componentes, en donde cada uno tiene su responsabilidad única y bien definida, además permite testear cada modulo independientemente y permite incorporar nuevas
            funcionalidades sin afectar el sistema general.
          </p>
        </section>

        <section id="punteros" class="content-section">
          <h2>4. Uso de Punteros a Funciones</h2>
          <p>
            Se ha implementado el uso de punteros a funciones para lograr una
            mayor flexibilidad y evitar múltiples condicionales al seleccionar
            la función de métrica a ejecutar. Se utiliza el siguiente typedef:
          </p>
          <pre><code>typedef char* (*MetricFunction)(int*, Order*);</code></pre>
          <p>
            En <code>main.c</code> se define, por ejemplo, una estructura
            <code>MetricMapping</code> que asocia el nombre de la métrica con la
            función correspondiente. Esto permite invocar dinámicamente la
            función adecuada según la métrica solicitada, haciendo el código más
            modular y fácil de extender.
          </p>
        </section>

        <section id="diagrama" class="content-section">
          <h2>5. Diagrama de Flujo del Programa</h2>
          <p>
            A continuación se presenta el diagrama general del flujo del
            programa, generado con PlantUML:
          </p>
          <div class="diagrama">
            <a href="https://github.com/Cseguuu/App1_Soler_Segu/tree/e48f92d2b5571c3bfc548ad3385f7e7e9963fc36/images/diagrama.png" target="_blank">
              Haz click aquí para ver el diagrama
            </a>
          </div>
          
          <p>
            El diagrama de flujo plantea lo siguiente: 
            <ul><li>1. Inicio: El programa recibe dos argumentos, el archivo CSV y la o las metricas a calcular.</li>
            <li>2. Apertura del archivo: Se intenta abrir el archivo, si es correcto procede, en el caso contrario da error y termina.</li>
            <li>3. Procesamiento de CSV: Se usa csv_parser para leer el archivo si es exitoso, almacena los datos en estructuras.</li>
            <li>4. Validación métrica: Verifica si es valida la métrica ingresada, si no lo es muestra mensaje de error, el caso contrario lo busca en la tabla MetricMapping.
            <li>5. Cálculo y resultado: llama a la función de la métrica solicitada, recibe el resultado y lo imprime.</li>
            <li>6. Liberación de memoria: Libera la memoria usada por las estructuras Order y los resultados.</li></ul>
          </p>
          Este enfoque modular permite separar responsabilidades, manejar errores de forma temprana y nos facilitó la incorporación de nuevas métricas sin necesidad de alterar la estructura general del código.
        </section>

        <section id="interaccion" class="content-section">
          <h2>6. Interacción entre Archivos</h2>
          <p>
            La comunicación entre los distintos módulos se realiza de la
            siguiente manera:
          </p>
          <ul>
            <li>
              <strong>De main.c a csv_parser.c:</strong> Se invoca la función de
              parseo para leer el archivo CSV y almacenar los pedidos en un
              arreglo de estructuras <code>Order</code>.
            </li>
            <li>
              <strong>De main.c a metrics.c:</strong> Se utiliza una tabla de
              mapeo que asocia nombres de métricas a sus funciones
              correspondientes. Dependiendo de la métrica solicitada, se llama a
              la función adecuada.
            </li>
            <li>
              <strong>Manejo de memoria:</strong> Tanto el arreglo de
              <code>Order</code> como los resultados de las métricas se
              gestionan dinámicamente, liberando la memoria al finalizar su uso.
            </li>
            <li>
              <strong>Comunicación mediante headers:</strong> Los archivos
              <code>.h</code> permiten que <code>main.c</code> conozca las
              funciones y estructuras definidas en los demás módulos.
            </li>
          </ul>
          En resumen, organizar el código en módulos y usar archivos header para definir interfaces claras hace que el sistema sea mucho más fácil de entender y mantener. Cada parte se encarga de algo específico, lo que permite trabajar de manera más ágil y sin complicaciones. Además, manejar la memoria dinámicamente y utilizar un mapeo para las métricas aporta flexibilidad y escalabilidad, ayudándonos a evitar problemas futuros y a hacer cambios sin romper todo el sistema.
        </section>

        <section id="recursos" class="content-section">
          <h2>7. Recursos Externos Utilizados</h2>
          
          <h3>Herramientas de Inteligencia Artificial</h3>
          <ul>
            <li>
              <strong>ChatGPT</strong>: Se utilizó para definir la estructura modular del proyecto y resolver dudas específicas relacionadas con punteros a funciones y buenas prácticas en C.
            </li>
            <li>
              <strong>Claude</strong>: Se empleó para complementar la información técnica necesaria en diversas etapas del desarrollo.
            </li>
          </ul>
          
          <h3>Documentación Oficial y Comunidades en Línea</h3>
          <ul>
            <li>
              <strong>Documentación oficial del lenguaje C</strong>: Se consultó para asegurar el cumplimiento de los estándares técnicos.
            </li>
            <li>
              <strong>Stack Overflow</strong>: Se recurrió a esta comunidad para abordar aspectos específicos del parseo de archivos CSV y la gestión de memoria.
            </li>
          </ul>
          
          <p>La integración de estas fuentes de apoyo garantizó que el desarrollo del código se realizara conforme a los estándares técnicos y los requerimientos establecidos en las bases del proyecto.</p>
        </section>
        
        <section id="reflexiones" class="content-section">
          <h2>8. Reflexiones Finales</h2>
          <p style="text-align: justify;">
            Al concluir este proyecto, cada integrante del equipo quiere compartir sus
            reflexiones sobre la experiencia, los aprendizajes y los desafíos
            encontrados:
          </p>
        
          <div style="margin: 30px 0; text-align: justify;">
            <h3 style="color: #00529b; border-bottom: 1px solid #00529b; padding-bottom: 5px; margin-bottom: 15px;">Cristobal Segú</h3>
            <p style="text-align: justify;">
              Lo más interesante de la tarea fue el aprender a trabajar con el lenguaje de programación C, ya que nunca me había enfrentado a este, con lo cual todo a lo que me enfrenté en esta tarea fue nuevo, teniendo que asimilar una gran cantidad de funciones y forma de este lenguaje tal como el manejo de la memoria dinámica, el emplear el debugging, el cual me fue más complejo que el comprender el lenguaje. A su vez el aprender a trabajar en equipo mediante GitHub, herramienta con la cual ya había trabajado con anterioridad, aunque sin entender a profundidad el funcionamiento de este y simplemente seguir instrucciones y mediante esta tarea me fue posible entender cómo opera esta herramienta. Una de las principales lecciones aprendidas mediante el uso de C fue el modularizar las funciones del programa, la gestión de la memoria, solicitando memoria al programa, el liberar los resultados para así no colapsar la RAM o aprender a realizarlo para futuros proyectos de mayor escala.
Uno de los errores a los cuales nos enfrentamos fue No such file or directory o que el programa no se ejecutaba correctamente. Esto lo enfrentamos mediante la utilización de GDB, se compilo el programa, luego se analizó el código paso a paso analizando todos los archivos, también se utilizó comandos para buscar errores, por ejemplo el programa fallaba en leer el csv y pusimos un breakpoint en la función de lectura y comprobamos si la ruta del archivo era correcta y luego si este se abría correctamente. Para las pruebas se creó un archivo csv de prueba para comprobar el correcto funcionamiento de las métricas en base a datos conocidos. 
            </p>
          </div>
        
          <div style="margin: 30px 0; text-align: justify;">
            <h3 style="color: #00529b; border-bottom: 1px solid #00529b; padding-bottom: 5px; margin-bottom: 15px;">Diego Soler</h3>
            <p style="text-align: justify;">
              En esta tarea me metí de lleno en C, un lenguaje que hasta ahora me era totalmente nuevo. Además, pude profundizar mis conocimientos en GitHub, lo que me ayudó a trabajar en equipo y a entender mejor cómo gestionar cambios y resolver conflictos en el código.

Al igual que mi compañero, uno de los desafíos fue el error "No such file or directory". Tuvimos que meter mano y revisar paso a paso para ver por qué no funcionaba, lo que nos ayudó a aprender más sobre debugging y manejo de rutas.

En resumen, la experiencia me dejó grandes aprendizajes sobre la modularización del código, la gestión de memoria y, sobre todo, a enfrentar y resolver problemas reales en equipo, apoyado en la ia pero siempre ocupandola de una manera crítica y de apoyo.
            </p>
          </div>
        

        </section>
      </div>
    </main>

    <footer>
      <div class="container">
        <p>© 2025 Grupo Cristobal Segú y Diego Soler</p>
      </div>
    </footer>

    <!-- Botón para subir -->
    <button id="scrollToTopBtn" onclick="scrollToTop()">&#8679;</button>

    <script>
      // Obtener el botón
      const scrollToTopBtn = document.getElementById("scrollToTopBtn");

      // Mostrar el botón cuando se hace scroll hacia abajo
      window.onscroll = function () {
        if (
          document.body.scrollTop > 20 ||
          document.documentElement.scrollTop > 20
        ) {
          scrollToTopBtn.style.display = "flex";
        } else {
          scrollToTopBtn.style.display = "none";
        }
      };

      // Función para subir suavemente al inicio
      function scrollToTop() {
        window.scrollTo({ top: 0, behavior: "smooth" });
      }
    </script>
  </body>
</html>